# -*- coding: utf-8 -*-
"""G7_final_coding.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RSM6kYW0pLiPq4BGWNNlkPf_1UPM1Jb6

# **Leveraging Unsupervised Clustering of Wind Patterns to Enhance Urban Sustainability in Smart Cities**

## Libraries
"""

import pandas as pd
import numpy as np
from scipy import stats
from scipy.stats import zscore
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import MinMaxScaler
import gdown
import streamlit as st


st.title("üå§Ô∏è Wind Pattern Clustering App")
st.write("This app clusters weather data using KMeans, DBSCAN, and Hierarchical clustering.")
"""## Load Dataset"""

url = 'https://drive.google.com/file/d/10FpRWYTw6K2wX3csaUv1T7B8kf0DiDqG/view?usp=drive_link'
output = 'minute_weather.csv'
gdown.download(url, output, quiet=False)
df = pd.read_csv('minute_weather.csv')

"""## Explore Dataset"""

# Print the first five rows of the DataFrame.
print(df.head())

# Print the shape of the DataFrame.
print(df.shape)

# Print the column names of the DataFrame.
print(df.columns)

# Print the data types of each column.
print(df.dtypes)

# Print the summary statistics of the DataFrame.
print(df.describe())

"""## Data Preprocessing

### Feature Engineering
"""

# Clean column names by stripping spaces
df.columns = df.columns.str.strip()

#Timestamp processing
df['hpwren_timestamp'] = pd.to_datetime(df['hpwren_timestamp'])

# Extract useful fe from the timestamp
df['year'] = df['hpwren_timestamp'].dt.year
df['month'] = df['hpwren_timestamp'].dt.month
df['day'] = df['hpwren_timestamp'].dt.day
df['hour'] = df['hpwren_timestamp'].dt.hour
df['minute'] = df['hpwren_timestamp'].dt.minute
df['second'] = df['hpwren_timestamp'].dt.second
df['timestamp'] = pd.to_datetime(df['hpwren_timestamp']).dt.time
df.rename(columns={'hpwren_timestamp': 'full_timestamp'}, inplace=True)
df.head()

"""### Missing Values"""

# Check for missing values
missing_values = df.isnull().sum()

# Display cleaned column names, missing values
df.columns, missing_values

# Drop all rows with any missing values in the DataFrame
print("Before drop:", df.shape)
df = df.dropna()
print("After drop:", df.shape)

"""### Duplicates rows"""

# Check for duplicate rows
duplicated_rows = df.duplicated().sum()
print(f"Number of duplicated rows: {duplicated_rows}")

"""### Invalid Values"""

print(df['rain_accumulation'].value_counts())

df['rain_accumulation'] = df['rain_duration'].apply(lambda x: 1 if x != 0 else 0)
print(df['rain_accumulation'].value_counts())
print(df['rain_duration'].value_counts())

"""### Outliers"""

outlier_cols = [
    'air_pressure', 'air_temp',
    'avg_wind_direction', 'avg_wind_speed',
    'max_wind_direction', 'max_wind_speed',
    'min_wind_direction', 'min_wind_speed',
    'relative_humidity'
]
plt.figure(figsize=(12, 6))
df[[col for col in outlier_cols if col != 'rain_duration']].boxplot(rot=45)
plt.title("Boxplot of Potential Outlier Columns")
plt.show()

non0_rain = df.loc[df['rain_duration'] != 0, 'rain_duration']
plt.figure(figsize=(12, 6))
non0_rain.plot.box(rot=45)
plt.title("Boxplot of Rain Duration")
plt.show()

# 1. Outlier detection for general columns using IQR
Q1 = df[outlier_cols].quantile(0.25)
Q3 = df[outlier_cols].quantile(0.75)
IQR = Q3 - Q1

lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Count outliers for each column in outlier_cols
outliers_count = ((df[outlier_cols] < lower_bound) | (df[outlier_cols] > upper_bound)).sum()
print("Outliers count for general columns:\n", outliers_count)

# 2. Outlier detection for rain_duration using z-score (for nonzero values only)
non0_rain = df.loc[df['rain_duration'] != 0, 'rain_duration']
z_scores = stats.zscore(non0_rain)
threshold = 3
non0_outliers_mask = np.abs(z_scores) > threshold
rain_duration_z_outliers_count = non0_outliers_mask.sum()
print("Outlier count for rain_duration (nonzero values, using zscore):", rain_duration_z_outliers_count)

# Get the indices of nonzero rain_duration outliers
non0_outlier_indices = non0_rain.index[non0_outliers_mask]

"""### Remove Outliers"""

print("Initial DataFrame shape:", df.shape)
# Remove rows with outliers in general columns (using IQR)
df = df[~((df[outlier_cols] < lower_bound) | (df[outlier_cols] > upper_bound)).any(axis=1)]

# Remove rows where rain_duration is nonzero and flagged as an outlier based on z-score
df = df[~((df['rain_duration'] != 0) & (df.index.isin(non0_outlier_indices)))]

print("DataFrame shape after outlier removal:", df.shape)

"""### Data Scaling"""

# Columns to scale (excluding wind direction)
features_to_scale = ['air_pressure', 'air_temp', 'avg_wind_speed',
                     'max_wind_speed', 'min_wind_speed',
                     'rain_duration', 'relative_humidity']

# Apply MinMaxScaler
scaler = MinMaxScaler()
df[features_to_scale] = scaler.fit_transform(df[features_to_scale])
df.describe()

"""## EDA

## **Visualize data**
"""

df.head()

#visualize = df.iloc[:, 1:-1]
visualize_columns = ['air_pressure', 'air_temp', 'avg_wind_direction', 'avg_wind_speed',
                     'max_wind_direction', 'max_wind_speed', 'min_wind_direction',
                     'min_wind_speed', 'relative_humidity', 'rain_accumulation', 'rain_duration']

visualize = df[visualize_columns]  # Select only these columns from df
visualize.describe()

"""#### Histogram"""

visualize.hist(figsize=(12, 8), bins=30)
plt.suptitle("Histograms of Features")
plt.show()

fig, axes = plt.subplots(1, 2, figsize=(12, 5))

# Rain Accumulation Histogram
sns.histplot(df['rain_accumulation'], bins=50, ax=axes[0], color='blue')
axes[0].set_yscale('log')
axes[0].set_title("Rain Accumulation Distribution (Log Scale)")
axes[0].set_xlabel("Rain Accumulation")
axes[0].set_ylabel("Frequency")

# Rain Duration Histogram
sns.histplot(df['rain_duration'], bins=50, ax=axes[1], color='green')
axes[1].set_yscale('log')
axes[1].set_title("Rain Duration Distribution (Log Scale)")
axes[1].set_xlabel("Rain Duration")
axes[1].set_ylabel("Frequency")

plt.tight_layout()
plt.show()

sns.pairplot(visualize)
plt.show()

"""### Feature Correlation Heatmap"""

plt.figure(figsize=(10, 8))
sns.heatmap(visualize.corr(), annot=True, cmap='coolwarm', fmt=".2f", linewidths=0.5)
plt.title("Feature Correlation Heatmap")
plt.show()

"""## **Wind_Direction**"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Function to categorize wind direction into N, NE, E, SE, S, SW, W, NW
def categorize_wind_direction(degrees):
    bins = [0, 45, 90, 135, 180, 225, 270, 315, 360]  # Corrected bin edges
    labels = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW']
    return pd.cut(degrees % 360, bins=bins, labels=labels, include_lowest=True)

# Apply categorization
df['avg_wind_category'] = categorize_wind_direction(df['avg_wind_direction'])
df['max_wind_category'] = categorize_wind_direction(df['max_wind_direction'])
df['min_wind_category'] = categorize_wind_direction(df['min_wind_direction'])

# Count occurrences
avg_counts = df['avg_wind_category'].value_counts().reindex(['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'], fill_value=0)
max_counts = df['max_wind_category'].value_counts().reindex(['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'], fill_value=0)
min_counts = df['min_wind_category'].value_counts().reindex(['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'], fill_value=0)

# Create figure with 2 rows (3 bar charts on top, 3 polar plots below)
fig, axes = plt.subplots(2, 3, figsize=(18, 12))

# Bar charts (Top Row)
axes[0, 0].bar(avg_counts.index, avg_counts.values, color='blue')
axes[0, 0].set_title("Average Wind Direction")
axes[0, 0].set_xlabel("Direction")
axes[0, 0].set_ylabel("Count")

axes[0, 1].bar(max_counts.index, max_counts.values, color='red')
axes[0, 1].set_title("Max Wind Direction")
axes[0, 1].set_xlabel("Direction")

axes[0, 2].bar(min_counts.index, min_counts.values, color='green')
axes[0, 2].set_title("Min Wind Direction")
axes[0, 2].set_xlabel("Direction")

# Polar plots (Bottom Row)
angles_avg = np.deg2rad(df['avg_wind_direction'])  # Convert to radians
angles_max = np.deg2rad(df['max_wind_direction'])
angles_min = np.deg2rad(df['min_wind_direction'])

# Average Wind Rose
ax1 = fig.add_subplot(2, 3, 4, projection='polar')
ax1.hist(angles_avg, bins=36, color='blue', alpha=0.75)
ax1.set_title("Wind Rose - Average Wind Direction")

# Max Wind Rose
ax2 = fig.add_subplot(2, 3, 5, projection='polar')
ax2.hist(angles_max, bins=36, color='red', alpha=0.75)
ax2.set_title("Wind Rose - Max Wind Direction")

# Min Wind Rose
ax3 = fig.add_subplot(2, 3, 6, projection='polar')
ax3.hist(angles_min, bins=36, color='green', alpha=0.75)
ax3.set_title("Wind Rose - Min Wind Direction")

# Adjust layout
plt.tight_layout()
plt.show()

"""#### Future Coding

#### For Wind_Direction
"""

df_scaled = df.copy()

# Convert wind direction columns into x, y components
for col in ['avg_wind_direction', 'min_wind_direction', 'max_wind_direction']:
    df_scaled[f'{col}_x'] = np.cos(np.radians(df[col]))
    df_scaled[f'{col}_y'] = np.sin(np.radians(df[col]))

# Drop original wind direction columns
df_scaled.drop(columns=['avg_wind_direction', 'min_wind_direction', 'max_wind_direction'], inplace=True)

# Print the transformed dataset
print(df_scaled.head())


# Recover wind direction angles from x, y
df_scaled['avg_wind_direction_deg'] = np.degrees(np.arctan2(df_scaled['avg_wind_direction_y'], df_scaled['avg_wind_direction_x'])) % 360
df_scaled['min_wind_direction_deg'] = np.degrees(np.arctan2(df_scaled['min_wind_direction_y'], df_scaled['min_wind_direction_x'])) % 360
df_scaled['max_wind_direction_deg'] = np.degrees(np.arctan2(df_scaled['max_wind_direction_y'], df_scaled['max_wind_direction_x'])) % 360

# Print the first few values
print(df_scaled[['avg_wind_direction_deg', 'min_wind_direction_deg', 'max_wind_direction_deg']].head())


plt.hist(df_scaled['avg_wind_direction_deg'], bins=36, edgecolor='black', alpha=0.7)  # 10¬∞ bins
plt.xlabel("Wind Direction (Degrees)")
plt.ylabel("Frequency")
plt.title("Wind Direction Distribution")
plt.show()

"""## Modeling

1. Silhouette Score
- Ranges from -1 to 1
- Closer to 1 = well-separated clusters
- Close to 0 = overlapping clusters
- Negative = wrong clustering

2. Number of Clusters
- Too few clusters ‚Üí underfitting (missing structure)
- Too many clusters ‚Üí overfitting (fitting noise)

3. Cluster Size Distribution
- Overfitting: many tiny clusters
- Underfitting: one or two large blobs

4. Visual Inspection (PCA/t-SNE plots)
- If clusters look meaningful and distinct ‚Üí good
- If everything overlaps or looks noisy ‚Üí under/overfit

### Example: Overfitting in K-Means
If k = 20 gives:
- Silhouette = 0.2
- Several clusters with <1% of data ‚Üí You‚Äôre likely overfitting

![Screenshot 2025-04-24 080332.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA6AAAADxCAYAAADV/9p+AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAGdASURBVHhe7d19WFRl/j/wN4ka0gwqKYOBspqIqEmBWSqEGhqkyfqwiKWNls5a6kpWmuayfCvX3VRazQwxQ3c31lIbyyA1lYBVy0WwfGAxlQQFNDJGAYuH+/fHcs5vzpkBBgQcp/fruuZSzn2e5pz7PHzOuT/3OAkhBIiIiIiIiIha2R3qAUREREREREStgQEoERERERERtQkGoERERERERNQm7C4AZUoqERERERGRY7K7ANTJyUk9iIiIiIiIiByA3QWgRERERERE5JgYgBIREREREVGbaPUAtKk5nU0dn4iIiIiIiG4PToIRHxEREREREbWBVn8DSkRERERERITWDkD5cpWIiIiIiIgkrRqANgeDViIiIiIiIsdkdwEofweUiIiIiIjIMdldAEpERERERESOqVUDUL7NJCIiIiIiIkmrBqDNwRxQIiIiIiIix2R3ASjfmhIRERERETkmuwtA20pNTQ2ysrJw7do1dRER/crk5OTAw8MDERERKC8vVxcTtYji4mL4+/vD398fxcXF6uIWV15ejoiICHh4eCAnJ0ddTEREdEu0egAaHx8PrVYLrVbb4M3dlStXEBQUBK1WiwEDBrT6xXnLli0YOXIknnzySVRUVKiLiegWqaqqgtFoxMiRI9G5c2f5/DF48GCsXLkSlZWV6kmILAghcOLECcycORM6nU6uRz179sTMmTORn5+vnuSWM5lMGDVqFLRaLT788EN1MQDgv//9L3r16oVevXrhv//9r7qYqNmkB3FarRZz585FVVWVehT5ns5gMKiLiIhs1uoBqLmvv/4aJ0+eVA8GAKSnpyMvL0892GYHDhxAZGQk3nnnHXWRVZ6enujYsSN8fX3RoUMHdTER3QIXL15EeHg4ZsyYgaysLGi1Wnh5eaFz5844f/48tm7dirKyMvVkRApVVVWIjY3FsGHDsGPHDlRVVcHLyws6nQ4//fQTduzYgdOnT6snu+W0Wi3CwsIAAJ9++imqq6vVo+Df//43rl69ipCQEPTp00ddTNQikpOTsW/fPvXgm1JdXY0dO3bgkUcewd69e9XFRPQr0mYBaM+ePfHLL7/g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pjiWe/fuLf74xz+K8vJyxfyJ6PbgJOysrakQgj3QEhEREREROaBb0gS3IQw+iYiIiIiIHJPdBaBERERERETkmBiAEhERERERUZuwuwDUzlJSiYiIiIiIqIXYXQDKHFAiIiIiIiLHZHcBKBERERERETkmBqBERERERETUJuwuAGUOKBERERERkWOyuwCUOaBERERERESOye4CUCIiIiIiInJMDECJiIiIiIioTdhdAMocUCIiIiIiIsdkdwEoc0CJiIiIiIgck90FoEREREREROSYGIASERERERFRm7C7AJQ5oERERERERI7J7gJQ5oASERERERE5JrsLQImIiIiIiMgxMQAlIiIiIiKiNuEkWjHpMi8vTz2oUUIINsMlIiIiIiJyQK0agBIRERERERFJ2ASXiIiIiIiI2gQDUCIiIiIiImoTdheAskUwERERERGRY7K7AJQdEBERERERETkmuwtAiYiIiIiIyDExACUiIiIiIqI2YXcBKHNAiYiIiIiIHJPdBaDMASUiIiIiInJMdheAEhERERERkWNiAEpERERERERtwu4CUOaAEhEREREROSa7C0CZA0pEREREROSY7C4AJSIiIiIiIsfEAJSIiIiIiIjahN0FoMwBJSIiIiIickx2F4AyB5SIiIiIiMgx2V0ASkRERERERI6JASgRERERERG1CbsLQJkDSkRERERE5JjsLgBlDigREREREZFjsosAVAiBkydPoqSkRB72+9//HlqtFqmpqQCA8vJyREREwMPDAzk5OWZTExERNV1OTg48PDzk6wwR0a2Uk5MDf39/3ueSw2uTADQ3NxdTpkyBp6cntFottFotBgwYgN27dwMAvvzySwwbNgxjxozB5cuX1ZOTFZWVlUhISMDgwYPlberu7o6ZM2eirKxMPTqR3UtNTYVWq0VERATKy8vVxQrx8fHQarWIj49XFzVbcXEx/P39W2ye8fHx8Pf3R3FxsbqI2oi0T6VzpPQxGAzqUR3eiRMnEBQU1Gj9rqysxN/+9jd4e3tDq9XC29sb69atQ1VVlXpUcjDS8WLLg37p4Y0t52uyTwaDoU3336/pmtjS9xOOqNUD0E8++QTDhw/Hnj17AABeXl64++67UVBQgDNnzgAA7r77bnTt2hX33nsvOnXqpJrD7aOwsBALFy7E9OnTFQd0dXU1duzYgUceeQR79+5V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NBqN8PLyEomJiWL16tUWvQWaTCbx8ssvCw8PD6HRaISbm5sICwtTfI/a2lqRmJgounfvLjQajRg+fLi4fPmyEEKIwsJCMXbsWHnajRs3ysNnzpwp92bbtWtXMXnyZHH69Gl52WrffPON0Ov1wtvbW/5+/v7+4o033hAmk0kx7unTp8Vjjz0mb38PDw/x6quvisrKSiHqvtfy5cuFl5eXvG6TJk1SLN/aNpbU1taKtLQ0MXz4cHldevfuLZYvX26xLkQNUfcEJ1mzZo1FT3fqHuaEWe+00iclJUXuNe7f//636N69u8V8pN49U+rpWVfd252w0iOgRN1DnXlPfOp1M/+Y97wnzdu83FqveWQbaf+qP+reHNX7Uj2dundEW/aTLeNYY15XzOueVD+bOj/JHFUvuNevXxcTJ04UXbt2VXx/6VonXZMefPBBkZaWJl/nyHFZOweKuro8bNgwix5C1ec8adyG6r10PyGVhYeHi/T0dPk4tFbP1edg9TjqeZiPoz62JdLxIH1a4jysnk59PVOvt7X5ZlvpUVUarj5XqZennl9D31EqV++/llrH+sYR9SxDvY/V9USj+oUJaR4ffvihYjz1NheN3Bs01gOwLdMK1TVjzZo1DR5L6n2mrqNrVD30mw9X78PbmZOor63oLSKEuOlmuERERERE1Pakt6hNzXm3VXHdb7WuXr26SW9myX60ahPc5mDwSURERER0+8nJyYGxgQ6riGCPASgREREREd1+AgICUFJSwjeT1CAGoERERERERNQmmANKREREREREbcLu3oAy+CQiIiIiInJMdheAEhERERERkWNiAEpERERERERtwu4CUDtLSSUiIiIiIqIWYncBKHNAiYiIiIiIHJPdBaBERERERETkmBiAEhERERERUZuwuwCUOaBERERERESOye4CUOaAEhEREREROSa7C0CJiIiIiIjIMTEAJSIiIiIiojZhdwEoc0CJiIiIiIgck90FoMwBJSIiIiIickx2F4ASERERERGRY2IASkRERERERG3CSbRi0uX169fVgxolhGAzXCIiIiIiIgfUqgEoERERERERkYRNcImIiIiIiKhNMAAlIiIiIiKiNmF3AShbBBMRERERETkmuwtA2QERERERERGRY7K7AJSIiIiIiIgcEwNQIiIiIiIiahN2F4AyB5SIiIiIiMgx2V0AyhxQ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73/H7373O/Xs6nXhwgUkJSVh586d+OmnnxAZGYn09HS54xtXV1f84x//wJtvvonOnTtj586dSElJQWBgIFJTUxUX9wkTJuCNN96Ai4sLMjMzcf78eWzatAn33nuvaqlKzs7OeOONN/Dcc8+hXbt2SElJwfnz5/H+++9jxIgR6tHtxuDBg5GcnIz+/fvj/Pnz2L59O8LDwxEfH2/xcwDz58/H5s2b4e3tjczMTCQlJeHq1auIjY1Fv379sGnTJnz++ecYMWIExo0bBwAYN24cRowYgYMHD2Lz5s1mSyZ75FrXZCvSSkc99i41NRWxsbGorKyUf9NL+kj5Lbq6vB7UtVqQytetW9foAzWqn06nw6lTpzB79mw5X0r6REVFNXjjm5CQIP+shDRNYmIijh8/rqiDS5culct9fX0xe/ZsuedHKZ9p5cqVimW7uro2+MbH/AZOa9a8MCAgAMePH0dGRobFMht6A4S6c+q+ffswbNgwZGZm4tChQ5g4cSJ2797dYDPa5k5Htz8pr9H8I9VFW48P1DWHP3HihOJ40+l0GDhwoCK4aE31HTvS/Zia9DYzKytLPicbjUaLnzwpKChQnFsSExNx4MABRQAqBQnaut9zdK1rQhscHKyYdtq0aXj88ccV87emoXOOmvQ9jHU5ldq6Fw/WckCtae45LDw8XJEbW9/2UzOZTIo6pdfrFb0t13dubK7G6kVTlhcTE4P09HT5J1jMt3dJSQnCw8Nx4MABJCYmQttIvrC1emNNTEyM3AzbfHm27l+1pnzfluIk7CwZTgjBJ6tEREREREQ2io+Px759+xQ/L2Ov2uwNqK0YfBIREREREdlGygFV96Bsr+wuACUiIiIiIiJLL774okUPwdLvkTa3GW5bYwBKRERERER0G7jnnnss+pYoKCjA0aNHG8zRtSfMASUiIiIiIqI2YXdvQBl8EhEREREROSa7C0CJiIiIiIjIMTEAJSIiIiIiojZhdwGonaWkEhERERERUQuxuwCUOaBERERERESOye4CUCIiIiIiInJMDECJiIiIiIioTdhdAMocUCIiIiIiIsdkdwEoc0CJiIiIiIgck90FoEREREREROSYGIASERERERFRm7C7AJQ5oERERERERI7J7gJQ5oASERERERE5JrsLQImIiIiIiMgxMQAlIiIiIiKiNuEkWjHp8vr16+pBjRJC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)
"""

from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from sklearn.cluster import KMeans, DBSCAN, AgglomerativeClustering
from sklearn.metrics import silhouette_score, davies_bouldin_score, calinski_harabasz_score
from sklearn.neighbors import NearestNeighbors
from scipy.cluster.hierarchy import linkage, dendrogram, fcluster
from scipy.spatial.distance import pdist

# Select only necessary features including scaled ones and directional components
features = [
    'air_pressure', 'air_temp', 'avg_wind_speed', 'max_wind_speed',
    'min_wind_speed', 'rain_duration', 'relative_humidity',
    'avg_wind_direction_x', 'avg_wind_direction_y',
    'min_wind_direction_x', 'min_wind_direction_y',
    'max_wind_direction_x', 'max_wind_direction_y'
]
df = df_scaled[features].dropna()

df_sample = df_scaled[features].sample(n=10000, random_state=42)

# Scale the data
scaler = StandardScaler()
X_scaled = scaler.fit_transform(df_sample)

# Reduce dimensionality for visualization
pca = PCA(n_components=2)
X_pca = pca.fit_transform(X_scaled)

# Function to evaluate clustering results
def evaluate_model(X, labels, name):
    n_clusters = len(set(labels)) - (1 if -1 in labels else 0)
    if n_clusters < 2:
        return (name, n_clusters, -1, -1, -1)
    sil = silhouette_score(X, labels)
    db = davies_bouldin_score(X, labels)
    ch = calinski_harabasz_score(X, labels)
    return (name, n_clusters, sil, db, ch)

# Default parameters
# Clustering - KMeans
kmeans = KMeans(n_clusters=4, random_state=42).fit(X_scaled)
labels_kmeans = kmeans.labels_

# Clustering - DBSCAN
dbscan = DBSCAN(eps=0.5, min_samples=5).fit(X_scaled)
labels_dbscan = dbscan.labels_

# Clustering - Hierarchical
hierarchical = AgglomerativeClustering(n_clusters=4).fit(X_scaled)
labels_hierarchical = hierarchical.labels_

# Visualize Dendrogram
linkage_matrix = linkage(X_scaled, method='average')
plt.figure(figsize=(10, 5))
dendrogram(linkage_matrix, truncate_mode='lastp', p=30, leaf_rotation=90., leaf_font_size=10.)
plt.title("Hierarchical Clustering Dendrogram")
plt.xlabel("Sample Index or (Cluster Size)")
plt.ylabel("Distance")
plt.tight_layout()
plt.grid(True)
plt.show()

# Evaluate each model
results = [
    evaluate_model(X_scaled, labels_kmeans, "KMeans"),
    evaluate_model(X_scaled, labels_dbscan, "DBSCAN"),
    evaluate_model(X_scaled, labels_hierarchical, "Hierarchical")
]

# Create DataFrame of results
results_df = pd.DataFrame(results, columns=["Model", "Num Clusters", "Silhouette Score", "Davies-Bouldin Index", "Calinski-Harabasz Index"])
results_df.sort_values(by="Silhouette Score", ascending=False, inplace=True)

# Visualize clusters (PCA)
fig, axs = plt.subplots(1, 3, figsize=(18, 5))
axs[0].scatter(X_pca[:, 0], X_pca[:, 1], c=kmeans.labels_, cmap='tab10')
axs[0].set_title('K-Means Clustering')

axs[1].scatter(X_pca[:, 0], X_pca[:, 1], c=dbscan.labels_, cmap='tab10')
axs[1].set_title('DBSCAN Clustering')

axs[2].scatter(X_pca[:, 0], X_pca[:, 1], c=hierarchical.labels_, cmap='tab10')
axs[2].set_title('Hierarchical Clustering')

plt.tight_layout()
plt.show()

# Display results
results_df

"""## Tune and find best parameters"""

### 1. Tune KMeans & Hierarchical over a range of k
k_range = range(2, 10)
sil_kmeans = []
sil_hierarchical = []

for k in k_range:
    km = KMeans(n_clusters=k, random_state=42).fit(X_scaled)
    km_score = silhouette_score(X_scaled, km.labels_)
    sil_kmeans.append(km_score)

    hc = AgglomerativeClustering(n_clusters=k).fit(X_scaled)
    hc_score = silhouette_score(X_scaled, hc.labels_)
    sil_hierarchical.append(hc_score)

# Plot Silhouette Scores for KMeans and Hierarchical
plt.figure(figsize=(10, 5))
plt.plot(k_range, sil_kmeans, marker='o', label='KMeans')
plt.plot(k_range, sil_hierarchical, marker='s', label='Hierarchical')
plt.title("Silhouette Score vs. Number of Clusters")
plt.xlabel("Number of Clusters")
plt.ylabel("Silhouette Score")
plt.legend()
plt.grid(True)
plt.show()


### 2. Tune DBSCAN over a range of eps and min_samples
eps_values = np.linspace(0.2, 1.1, 10)
min_samples_values = [5, 10, 15]
dbscan_results = []

for eps in eps_values:
    for min_samples in min_samples_values:
        db = DBSCAN(eps=eps, min_samples=min_samples).fit(X_scaled)
        labels = db.labels_
        n_clusters = len(set(labels)) - (1 if -1 in labels else 0)
        if n_clusters >= 2:
            sil = silhouette_score(X_scaled, labels)
            dbscan_results.append((eps, min_samples, n_clusters, sil))

# Convert to DataFrame and show top results
dbscan_df = pd.DataFrame(dbscan_results, columns=["eps", "min_samples", "n_clusters", "silhouette_score"])
dbscan_df.sort_values(by="silhouette_score", ascending=False).head(10)

"""## Try using different parameters"""

# Best Result
# Use the parameters got after tuning
# Clustering - KMeans(k=2)
kmeans = KMeans(n_clusters=2, random_state=42).fit(X_scaled)
labels_kmeans = kmeans.labels_

# Clustering - DBSCAN(eps=1.0, min_samples=10)
dbscan = DBSCAN(eps=1.1, min_samples=10).fit(X_scaled)
labels_dbscan = dbscan.labels_

# Clustering - Hierarchical(k=2)
hierarchical = AgglomerativeClustering(n_clusters=2, linkage='ward').fit(X_scaled)
labels_hierarchical = hierarchical.labels_

# Visualize Dendrogram
linkage_matrix = linkage(X_scaled, method='average')
plt.figure(figsize=(10, 5))
dendrogram(linkage_matrix, truncate_mode='lastp', p=30, leaf_rotation=90., leaf_font_size=10.)
plt.title("Hierarchical Clustering Dendrogram")
plt.xlabel("Sample Index or (Cluster Size)")
plt.ylabel("Distance")
plt.tight_layout()
plt.grid(True)
plt.show()

# Evaluate each model
results = [
    evaluate_model(X_scaled, labels_kmeans, "KMeans"),
    evaluate_model(X_scaled, labels_dbscan, "DBSCAN"),
    evaluate_model(X_scaled, labels_hierarchical, "Hierarchical")
]

# Create DataFrame of results
results_df = pd.DataFrame(results, columns=["Model", "Num Clusters", "Silhouette Score", "Davies-Bouldin Index", "Calinski-Harabasz Index"])
results_df.sort_values(by="Silhouette Score", ascending=False, inplace=True)

# Visualize clusters (PCA)
fig, axs = plt.subplots(1, 3, figsize=(18, 5))
axs[0].scatter(X_pca[:, 0], X_pca[:, 1], c=kmeans.labels_, cmap='tab10')
axs[0].set_title('K-Means Clustering')

axs[1].scatter(X_pca[:, 0], X_pca[:, 1], c=dbscan.labels_, cmap='tab10')
axs[1].set_title('DBSCAN Clustering')

axs[2].scatter(X_pca[:, 0], X_pca[:, 1], c=hierarchical.labels_, cmap='tab10')
axs[2].set_title('Hierarchical Clustering')

plt.tight_layout()
plt.show()

# Display results
results_df

# Clustering - KMeans(k=4)
kmeans2 = KMeans(n_clusters=5, random_state=42).fit(X_scaled)
labels_kmeans2 = kmeans2.labels_

# Clustering - DBSCAN(eps=1.5, min_samples=10)
dbscan2 = DBSCAN(eps=0.6, min_samples=10).fit(X_scaled)
labels_dbscan2 = dbscan2.labels_

# Clustering - Hierarchical(k=2)
hierarchical2 = AgglomerativeClustering(n_clusters=3, linkage='ward').fit(X_scaled)
labels_hierarchical2 = hierarchical2.labels_

# Visualize Dendrogram
linkage_matrix = linkage(X_scaled, method='average')
plt.figure(figsize=(10, 5))
dendrogram(linkage_matrix, truncate_mode='lastp', p=30, leaf_rotation=90., leaf_font_size=10.)
plt.title("Hierarchical Clustering Dendrogram")
plt.xlabel("Sample Index or (Cluster Size)")
plt.ylabel("Distance")
plt.tight_layout()
plt.grid(True)
plt.show()

# Evaluate each model
results = [
    evaluate_model(X_scaled, labels_kmeans2, "KMeans"),
    evaluate_model(X_scaled, labels_dbscan2, "DBSCAN"),
    evaluate_model(X_scaled, labels_hierarchical2, "Hierarchical")
]

# Create DataFrame of results
results_df2 = pd.DataFrame(results, columns=["Model", "Num Clusters", "Silhouette Score", "Davies-Bouldin Index", "Calinski-Harabasz Index"])
results_df.sort_values(by="Silhouette Score", ascending=False, inplace=True)

# Visualize clusters (PCA)
fig, axs = plt.subplots(1, 3, figsize=(18, 5))
axs[0].scatter(X_pca[:, 0], X_pca[:, 1], c=labels_kmeans2, cmap='tab10')
axs[0].set_title('K-Means Clustering')

axs[1].scatter(X_pca[:, 0], X_pca[:, 1], c=labels_dbscan2, cmap='tab10')
axs[1].set_title('DBSCAN Clustering')

axs[2].scatter(X_pca[:, 0], X_pca[:, 1], c=labels_hierarchical2, cmap='tab10')
axs[2].set_title('Hierarchical Clustering')

plt.tight_layout()
plt.show()

# Display results
results_df2

# Interpret the Clusters
kmeans_centers = kmeans.cluster_centers_
kmeans_cluster_analysis = pd.DataFrame(kmeans_centers, columns=features)
print("\nKMeans Cluster Centers Analysis:")
print(kmeans_cluster_analysis)

"""Based on the KMeans Cluster Centers Analysis, let's qualitatively describe each cluster:

###**Cluster 0:**
*   Air Pressure: High air pressure (+0.34).
*   Temperature: Slightly higher than average (+0.14).
*   Wind Speed: Generally low average wind speed (-0.32) and low maximum wind speed (-0.30).
*   Rain Duration: Low or short periods of rain (-0.04).
*   Relative Humidity: Low relative humidity (-0.38), indicating drier conditions.
*   Wind Direction: Strong positive component in the x-axis of the wind direction (+1.01), meaning winds primarily come from the east or southeast.
*   Description: This cluster could represent steady, mild winds in areas with stable weather conditions and low moisture. The wind likely flows in a predominantly consistent direction but with low speeds, ideal for areas where ventilation or cooling is needed but not excessive force.
*   Qualitative description: "Moderate, steady winds with lower variability".

###**Cluster 1:**
*   Air Pressure: Lower air pressure (-0.26).
*   Temperature: Slightly cooler than average (-0.11).
*   Wind Speed: Moderate wind speeds (+0.24 for average and +0.23 for max wind speeds), indicating stronger winds compared to Cluster 0.
*   Rain Duration: Longer rain durations (+0.03), suggesting this cluster experiences more rainfall or longer rainfall periods.
*   Relative Humidity: Higher relative humidity (+0.29), indicating slightly more moisture in the air.
*   Wind Direction: Strong negative components in the x-axis of wind direction (-0.76), suggesting winds primarily come from the west or northwest.
*   Description: This cluster is associated with stronger, more variable winds, likely from changing weather patterns or different wind zones. The winds are more unpredictable, likely in areas affected by changing or turbulent weather conditions, with occasional rainstorms. This would be more suitable for regions needing wind energy generation or increased natural ventilation in buildings.
*   Qualitative description: "Stronger, more erratic winds".

###**Summary**
* Cluster 0 represents areas with low wind speed and dry, stable conditions with moderate airflow from the southeast.

* Cluster 1 represents regions with stronger winds and more humid, rainy conditions, likely with winds from the northwest.

* These clusters can provide insights into how urban design could be adjusted to improve ventilation or mitigate heat islands, depending on which type of wind pattern dominates different city areas.
"""
st.markdown("---")
st.markdown("### üîó [Try this app online](https://g7-deployment.streamlit.app)")
